#include <math.h>

/* standard C style wrapper */
/* Subroutine */ int
calci0_ (double *arg, double *result, int *jint)
{
  /* Initialized data */

  static double one = 1.;
  static double p[15] = { -5.24878666279456998e-18,
    -1.5982226675653184646e-14, -2.6843448573468483278e-11,
    -3.0517226450451067446e-8, -2.5172644670688975051e-5,
    -.015453977791786851041, -7.093534744921054919,
    -2412.5195876041896775, -595456.26019847898221,
    -103130667.08737980747, -11912746104.985237192,
    -849251012471.14157499, -32940087627407.749166,
    -550503696730184.27753, -2233558263947437.5249
  };
  static double q[5] = { -3727.7560179962773046, 6515850.6418655165707,
    -6562656074.0833869295, 3760418870409.2954661,
    -970879461795940.19126
  };
  static double pp[8] = { -.3984375, 2.9205384596336793945,
    -2.4708469169133954315, .47914889422856814203,
    -.003738499192606896915, -.002680152035332863531,
    9.9168777670983678974e-5, -2.187712818903272673e-6
  };
  static double qq[7] = { -31.4466902751354915, 85.5395632580129296,
    -60.228002066743340583, 13.982595353892851542,
    -1.1151759188741312645, .032547697594819615062,
    -5.5194330231005480228e-4
  };
  static double one5 = 15.;
  static double exp40 = 235385266837019985.4;
  static double forty = 40.;
  static double rec15 = .066666666666666666666;
  static double two25 = 225.;
  static double xsmall = 5.55e-17;
  static double xinf = 1.79e308;
  static double xmax = 713.986;

  /* Builtin functions */
  double exp (double), sqrt (double);

  /* Local variables */
  static double sump, sumq, a, b;
  static int i__;
  static double x, xx;

/* -------------------------------------------------------------------- */

/* This packet computes modified Bessel functions of the first kind */
/*   and order zero, I0(X) and EXP(-ABS(X))*I0(X), for real */
/*   arguments X.  It contains two function type subprograms, BESI0 */
/*   and BESEI0, and one subroutine type subprogram, CALCI0. */
/*   The calling statements for the primary entries are */

/*                   Y=BESI0(X) */
/*   and */
/*                   Y=BESEI0(X) */

/*   where the entry points correspond to the functions I0(X) and */
/*   EXP(-ABS(X))*I0(X), respectively.  The routine CALCI0 is */
/*   intended for internal packet use only, all computations within */
/*   the packet being concentrated in this routine.  The function */
/*   subprograms invoke CALCI0 with the statement */
/*          CALL CALCI0(ARG,RESULT,JINT) */
/*   where the parameter usage is as follows */

/*      Function                     Parameters for CALCI0 */
/*       Call              ARG                  RESULT          JINT */

/*     BESI0(ARG)    ABS(ARG) .LE. XMAX        I0(ARG)           1 */
/*     BESEI0(ARG)    any real ARG        EXP(-ABS(ARG))*I0(ARG) 2 */

/*   The main computation evaluates slightly modified forms of */
/*   minimax approximations generated by Blair and Edwards, Chalk */
/*   River (Atomic Energy of Canada Limited) Report AECL-4928, */
/*   October, 1974.  This transportable program is patterned after */
/*   the machine-dependent FUNPACK packet NATSI0, but cannot match */
/*   that version for efficiency or accuracy.  This version uses */
/*   rational functions that theoretically approximate I-SUB-0(X) */
/*   to at least 18 significant decimal digits.  The accuracy */
/*   achieved depends on the arithmetic system, the compiler, the */
/*   intrinsic functions, and proper selection of the machine- */
/*   dependent constants. */

/* ******************************************************************* */
/* ******************************************************************* */

/* Explanation of machine-dependent constants */

/*   beta   = Radix for the floating-point system */
/*   maxexp = Smallest power of beta that overflows */
/*   XSMALL = Positive argument such that 1.0 - X = 1.0 to */
/*            machine precision for all ABS(X) .LE. XSMALL. */
/*   XINF =   Largest positive machine number; approximately */
/*            beta**maxexp */
/*   XMAX =   Largest argument acceptable to BESI0;  Solution to */
/*            equation: */
/*               W(X) * (1+1/(8*X)+9/(128*X**2) = beta**maxexp */
/*            where  W(X) = EXP(X)/SQRT(2*PI*X) */


/*     Approximate values for some important machines are: */

/*                          beta       maxexp       XSMALL */

/* CRAY-1        (S.P.)       2         8191       3.55E-15 */
/* Cyber 180/855 */
/*   under NOS   (S.P.)       2         1070       3.55E-15 */
/* IEEE (IBM/XT, */
/*   SUN, etc.)  (S.P.)       2          128       2.98E-8 */
/* IEEE (IBM/XT, */
/*   SUN, etc.)  (D.P.)       2         1024       5.55D-17 */
/* IBM 3033      (D.P.)      16           63       6.95D-18 */
/* VAX           (S.P.)       2          127       2.98E-8 */
/* VAX D-Format  (D.P.)       2          127       6.95D-18 */
/* VAX G-Format  (D.P.)       2         1023       5.55D-17 */


/*                               XINF          XMAX */

/* CRAY-1        (S.P.)       5.45E+2465     5682.810 */
/* Cyber 180/855 */
/*   under NOS   (S.P.)       1.26E+322       745.893 */
/* IEEE (IBM/XT, */
/*   SUN, etc.)  (S.P.)       3.40E+38         91.900 */
/* IEEE (IBM/XT, */
/*   SUN, etc.)  (D.P.)       1.79D+308       713.986 */
/* IBM 3033      (D.P.)       7.23D+75        178.182 */
/* VAX           (S.P.)       1.70D+38         91.203 */
/* VAX D-Format  (D.P.)       1.70D+38         91.203 */
/* VAX G-Format  (D.P.)       8.98D+307       713.293 */

/* ******************************************************************* */
/* ******************************************************************* */

/* Error returns */

/*  The program returns XINF for BESI0 for ABS(ARG) .GT. XMAX. */


/*  Intrinsic functions required are: */

/*     ABS, SQRT, EXP */


/*  Authors: W. J. Cody and L. Stoltz */
/*           Mathematics and Computer Science Division */
/*           Argonne National Laboratory */
/*           Argonne, IL 60439 */

/*  Latest modification: June 7, 1988 */

/* -------------------------------------------------------------------- */
/* -------------------------------------------------------------------- */
/*  Mathematical constants */
/* -------------------------------------------------------------------- */
/* -------------------------------------------------------------------- */
/*  Machine-dependent constants */
/* -------------------------------------------------------------------- */
/* -------------------------------------------------------------------- */
/*  Coefficients for XSMALL .LE. ABS(ARG) .LT. 15.0 */
/* -------------------------------------------------------------------- */
/* -------------------------------------------------------------------- */
/*  Coefficients for 15.0 .LE. ABS(ARG) */
/* -------------------------------------------------------------------- */
/* -------------------------------------------------------------------- */
  x = fabs (*arg);
  if (x < xsmall)
    {
      *result = one;
    }
  else if (x < one5)
    {
/* -------------------------------------------------------------------- */
/*  XSMALL .LE.  ABS(ARG)  .LT. 15.0 */
/* -------------------------------------------------------------------- */
      xx = x * x;
      sump = p[0];
      for (i__ = 2; i__ <= 15; ++i__)
	{
	  sump = sump * xx + p[i__ - 1];
/* L50: */
	}
      xx -= two25;
      sumq =
	((((xx + q[0]) * xx + q[1]) * xx + q[2]) * xx + q[3]) * xx + q[4];
      *result = sump / sumq;
      if (*jint == 2)
	{
	  *result *= exp (-x);
	}
    }
  else if (x >= one5)
    {
      if (*jint == 1 && x > xmax)
	{
	  *result = xinf;
	}
      else
	{
/* -------------------------------------------------------------------- */
/*  15.0  .LE.  ABS(ARG) */
/* -------------------------------------------------------------------- */
	  xx = one / x - rec15;
	  sump = ((((((pp[0] * xx + pp[1]) * xx + pp[2]) * xx + pp[3]) * xx
		    + pp[4]) * xx + pp[5]) * xx + pp[6]) * xx + pp[7];
	  sumq = ((((((xx + qq[0]) * xx + qq[1]) * xx + qq[2]) * xx + qq[3])
		   * xx + qq[4]) * xx + qq[5]) * xx + qq[6];
	  *result = sump / sumq;
	  if (*jint == 2)
	    {
	      *result = (*result - pp[0]) / sqrt (x);
	    }
	  else
	    {
/* -------------------------------------------------------------------- */
/*  Calculation reformulated to avoid premature overflow */
/* -------------------------------------------------------------------- */
	      if (x <= xmax - one5)
		{
		  a = exp (x);
		  b = one;
		}
	      else
		{
		  a = exp (x - forty);
		  b = exp40;
		}
	      *result = (*result * a - pp[0] * a) / sqrt (x) * b;
	    }
	}
    }
/* -------------------------------------------------------------------- */
/*  Return for ABS(ARG) .LT. XSMALL */
/* -------------------------------------------------------------------- */
  return 0;
/* ----------- Last line of CALCI0 ----------- */
}				/* calci0_ */

double
besi0_ (double *x)
{
  /* System generated locals */
  double ret_val;

  /* Local variables */
  static int jint;
  extern /* Subroutine */ int calci0_ (double *arg, double *result,
				       int *jint);
  static double result;

/* -------------------------------------------------------------------- */

/* This long precision subprogram computes approximate values for */
/*   modified Bessel functions of the first kind of order zero for */
/*   arguments ABS(ARG) .LE. XMAX  (see comments heading CALCI0). */

/* -------------------------------------------------------------------- */
/* -------------------------------------------------------------------- */
  jint = 1;
  calci0_ (x, &result, &jint);
  ret_val = result;
  return ret_val;
/* ---------- Last line of BESI0 ---------- */
}				/* besi0_ */

double
besei0_ (double *x)
{
  /* System generated locals */
  double ret_val;

  /* Local variables */
  static int jint;
  extern /* Subroutine */ int calci0_ (double *arg, double *result,
				       int *jint);
  static double result;

/* -------------------------------------------------------------------- */

/* This function program computes approximate values for the */
/*   modified Bessel function of the first kind of order zero */
/*   multiplied by EXP(-ABS(X)), where EXP is the */
/*   exponential function, ABS is the absolute value, and X */
/*   is any argument. */

/* -------------------------------------------------------------------- */
/* -------------------------------------------------------------------- */
  jint = 2;
  calci0_ (x, &result, &jint);
  ret_val = result;
  return ret_val;
/* ---------- Last line of BESEI0 ---------- */
}				/* besei0_ */

double
netlibi0 (double x)
{
  double arg = x;
  return besi0_ (&arg);
}

